#!/usr/bin/perl -w

use strict;
use warnings;
use 5.006;
use Time::HiRes qw( gettimeofday tv_interval sleep );

# Make sure we have the proper dependencies installed
my @deps = qw(
  Net::SAPO::Broker
  Getopt::Long
  LWP::UserAgent
);

foreach my $module (@deps) {
	eval "require $module; import $module ();";
	if ($@) {
	  my $mesg = <<"    OOPS";
	    ERROR: You seem to be missing the '$module' module.
	    
	    Unfortunately I require that module to do my job. Use:

	      cpan $module
	      
	    to install it.
    OOPS
    _write_err_mesg($mesg);
    exit(1);
	}
}

# Parse command line

my (
  $subscribe, $publish,
  $queue, $remove,
  $count, $rate, $size,
  $quiet, $help,
  $host, $port,
);
$quiet = 1 unless -t \*STDIN;
$size  = 70;
$count = 1000;

my $ok = GetOptions(
  "subscribe" => \$subscribe,
  "publish"   => \$publish,
  
  "queue=s"   => \$queue,
  "remove"    => \$remove,
  
  "count=s"   => \$count,
  "rate=s"    => \$rate,
  "size=s"    => \$size,
  
  "host=s"    => \$host,
  "port=s"    => \$port,
  
  "quiet"     => \$quiet,
  "help"      => \$help,
);

usage() unless $ok;
usage() if $help;

usage("Invalid --rate, must be greater than 0")
  if defined($rate) && $rate <= 0;

usage("Minimal payload size is 10")
  if $size < 10;

usage("Load generation and Queue operations do not mix")
  if $rate && $remove;

usage("The remove operation requires a queue identifier")
  if $remove && !$queue;

usage("Only one off 'subscribe' or 'publish' can be used")
  if $subscribe && $publish;

usage("Load generation and Basic PubSub operations do not mix")
  if $rate && ($publish || $subscribe);

my @topics = @ARGV;
@ARGV = ();
usage("Need set of topics to publish/subscribe to") unless $remove || @topics;

# Run the proper role
if ($publish) {
  publisher();
}
elsif ($queue && $remove) {
  queue_remove();
}
elsif ($rate) {
  load_generator();
}
else {
  subscriber();
}


### Roles

sub subscriber {
  my $sb = get_agent_connection();
  
  foreach my $topic (@topics) {
    $sb->subscribe({
      topic      => $topic,
      on_success => sub {
        diag("%% Subscribed topic '$topic'.");
      },
      on_error => sub {
        diag("ERROR subscribing to topic '$topic':");
        foreach my $e (@_) {
          next if ref($e);
          diag("    $e");
        }
      },
      on_message => sub {
        my (undef, $payload, $topic) = @_;
        my ($now, $count, $rate, $delta) = _calc_rate($topic);

        my $rt = sprintf('%0.3f mesg/sec (%d messages)', $rate, $count);
        my $ts = localtime($now->[0]);
        substr($ts, -5, 0, '.'.substr($now->[1], 0, 4));
        $ts .= sprintf(' (%0.3f elapsed since last message)', $delta) if $delta;
        
        my $len = length($payload);

        diag("** Got message on topic '$topic':");
        diag("** at $ts");
        diag("** rate for topic is $rt");
        diag();
        diag("-- Message starts (length $len)");
        print $payload,"\n";
        diag("-- Message ends");
        diag();
      }
    })
  }
  
  # Temp hack, deliver_messages() should wait forever
  while (1) { $sb->deliver_messages(5) };
}

sub publisher {
  my $sb = get_agent_connection();
  
  diag('Enter a message per line. Each non-empty line will be sent');
  diag('to the following topics:');
  foreach my $topic (@topics) {
    diag("    * $topic");
  }
  diag("");
  diag('Type ^D to exit');
  diag();
  
  while (my $msg = <>) {
    chomp($msg);
    next if $msg =~ m/^\s*$/;
    
    broadcast($sb, $msg);
  }
}

sub queue_remove {
  my $ua = LWP::UserAgent->new;
  $ua->timeout(2);
  
  # Hack! Move this to Protocol eventually
  $host ||= '127.0.0.1';
  my $url = "http://$host:3380/broker/admin";
  my $response = $ua->post($url, Content => "QUEUE:$queue");
  
  if (! $response->is_success) {
    diag("ERROR while removing queue '$queue'");
    diag("Full HTTP response: \n",$response->as_string);
    
    exit(1);
  }
  
  return;
}

sub load_generator {
  my $sb = get_agent_connection();
  my $delay = 1 / $rate;

  if ($count > 0) {
    diag("** Generating $count messages (payload size is $size)");
  }
  else {
    $count = 0;
    diag("** Generating unlimited messages (payload size is $size)");
  }
  diag("** at a rate of $rate mesg/sec");
  diag("** You can abort with ^C at any time");

  diag("** Running....");
  my $start = [gettimeofday()];  
  my $mesg_number = 0;
  while (1) {
    $mesg_number++;
    my $payload = "N=$mesg_number;";
    $payload .= ' ' x ($size - length($payload));
    
    broadcast($sb, $payload);
    sleep($delay);
    
    next unless $count;
    $count--;
    last unless $count;
  }
  
  my $actual_rate = $mesg_number / (tv_interval($start) || 1);
  diag('** Done!');
  diag("** Sent $mesg_number messages, requested rate $rate mesg/sec");
  diag("** Actual rate was $actual_rate mesg/sec");
}

### Agent connection

sub get_agent_connection {
  return Net::SAPO::Broker->new({
    host => $host,
    port => $port,

    on_state_connecting => sub {
      my ($sb) = @_;
      my $agent = $sb->host;
      diag("## Connecting to agent at '$agent'");
    },
    on_connected => sub {
      diag("## Connected!");
    },
    on_eof => sub {
      diag("## Lost connection to agent");
    },
    on_state_disconnecting => sub {
      diag("## Disconnecting");
    },
    on_reconnect => sub {
      diag("## Reconnecting");
    },
    on_read_error => sub {
      my (undef, $e) = @_;
      diag("## Read error: $e");
    },
    on_write_error => sub {
      my (undef, $e) = @_;
      diag("## Write error: $e");
    },
  });
}

### Multi-topic publish

sub broadcast {
  my ($sb, $payload) = @_;
  
  foreach my $topic (@topics) {
    $sb->publish({
      topic   => $topic,
      payload => $payload,

      # on_error => sub {
      #   diag("!! Could not send message to topic '$topic'");
      #   diag("!! Payload is: $payload");
      # },
    });
  }
  
  return;
}


### Diagnostics

sub diag {
  print @_,"\n" unless $quiet;
}


### Rate calculations

our %topic_rate;

sub _calc_rate {
  my ($topic) = @_;
  my $now = [gettimeofday()];
  my ($delta, $rate, $count);
  
  my $stats = $topic_rate{$topic};
  
  if ($stats) {
    $count      = ++$stats->[1];
    $delta      = tv_interval($stats->[2], $now);
    $stats->[2] = $now;
    
    my $since_start = tv_interval($stats->[0], $now);
    $rate = $count / ($since_start||1);
  }
  else {
    $topic_rate{$topic} = [$now, 1, $now];
    $delta = 0;
    $rate  = 0;
    $count = 1
  }

  return ($now, $count, $rate, $delta);  
}


### Usage

sub usage {
  my ($mesg) = @_;
  
  print STDERR "ERROR: $mesg\n" if $mesg;
  _write_err_mesg(<<"  USAGE");
    Usage: sapo-broker-client [options] [topic...]
    
     Basic Publish/Subscribe:
        --subscribe   prints new messages from any of the topics
        --publish     sends each non-empty lines from stdin to all the topics
      
        * --subscribe is the default;
        * You cannot use --subscribe and --publish simultaneously.
      
     Queue manipulations:
        --queue       specify the queue to work with
        --remove      removes the specified queue
    
     Load Generation:
        --count=N     how many messages to generate [defaults to 1000]
        --size=N      size of each payload [default to 70 bytes]
        --rate=N      desired messages per second (approximation)
        
        * rate can be decimal value, must be above 0;
        * rate is an approximation, does not take in account over-head;
        * minimal size is 10.
        
     General options:
        --host        connect to a specific host [defaults to 127.0.0.1]
        --port        connect to a specific TCP port [default to 3322]
        --quiet       disables diagnostic messages
        --help        shows this file
        
        * If either STDIN or STDOUT is not a tty, --quiet is turned on.
        
  USAGE
  exit(1);
}

sub _write_err_mesg {
  my ($mesg) = @_;
  
  my ($prefix) = $mesg =~ /^(\s+)/;
  $mesg =~ s/^$prefix//gsm;
  print STDERR "\n",$mesg,"\n";
}